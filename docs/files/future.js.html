<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>future.js - Futurejs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Futurejs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Completer.html">Completer</a></li>
            
                <li><a href="../classes/Future.html">Future</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: future.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Futurejs v{{VERSION}}
 * https://github.com/ertrzyiks/futurejs
 *
 * Dart Future and Completer features ported to javascript.
 */
(function(){
	
	var root = this;
	
	var nextTick;
	
	//Prefer process.nextTick, than timeout on nodejs
	if ( typeof(process) != &quot;undefined&quot; &amp;&amp; isFunction(process.nextTick))
	{
		nextTick = function( cb ){
			process.nextTick(cb);
		};
	}
	else
	{
		nextTick = function( cb ){
			setTimeout(cb, 0);
		};
	}
	
	/**
	 * &#x60;Future&#x60; is representation of asynchronous task.
	 *
	 * By default creates new instance of uncompleted &#x60;Future&#x60;.
	 *
	 * When &#x60;value&#x60; is given, creates a completed Future with &#x60;data&#x60; equals to:
	 * - &#x60;value()&#x60; , when &#x60;value&#x60; is function
	 * - &#x60;value&#x60; , otherwise
	 *
	 * When &#x60;withError&#x60; parameter is passed and can be treat as true, then new object is completed with error. 
	 * In this case, value is used as error object.
	 *
	 * For convenience and API compatibility there are 3 shortcuts for creating synchronous &#x60;Future&#x60;s.
	 *
	 * - &#x60;Future.value( value )&#x60;
	 * - &#x60;Future.sync( fn )&#x60;
	 * - &#x60;Future.error( e )&#x60;
	 *
	 * @class Future
	 * @constructor
	 * @param {Object|Function} [value] Completion &#x60;data&#x60; or error object
	 * @param {boolean} [withError] 
	 */
	var Future = function( value, withError )
	{ 
		if ( !isUndefined( value ) )
		{
			var v;
			if ( isFunction( value ) )
			{
				v = value();
			}
			else
			{
				v = value;
			}
			
			this._pending = false;
			if ( withError )
			{
				this._withError = true;
				this._error = v;
			}
			else
			{
				this._data = v;
			}
		}
		
		this._callbacks = [];
	};
	
	/**
	 * Create new &#x60;Future&#x60;, synchronously completed with &#x60;value&#x60;.
	 * 
	 * @method value 
	 * @param {Object} value
	 * @return {Future}
	 * @static
	 */
	Future.value = function( value )
	{
		return new Future( value );
	}
	
	/**
	 * Create new &#x60;Future&#x60;, synchronously completed with result of &#x60;value&#x60; function.
	 *
	 * @method sync
	 * @param {Function} value
	 * @return {Future}
	 * @static
	 */
	Future.sync = function( value )
	{
		if( !isFunction( value ) )
		{
			throw new Error(&quot;Future.sync value should be a function&quot;);
		}
		return new Future( value );
	}
	
	/**
	 * Create new &#x60;Future&#x60;, synchronously completed with error, &#x60;value&#x60; is used as error object.
	 *
	 * @method error
	 * @param {Object|Function} e
	 * @return {Future}
	 * @static
	 */
	Future.error = function( e )
	{
		return new Future( e, true );
	}
	
	/**
	 * Determine if &#x60;Future&#x60; is completed (false) or not (true).
	 *
	 * @property {Boolean} _pending
	 * @private
	 */
	Future.prototype._pending = true;
	
	/**
	 * Hold completion &#x60;data&#x60;.
	 *
	 * @property {Object} _data
	 * @private
	 */
	Future.prototype._data = null;
	
	/**
	 * Hold completion error object.
	 *
	 * @property {Object} _error
	 * @private
	 */
	Future.prototype._error = null;
	
	/**
	 * Determine if completion was with error (true) or not (false)
	 *
	 * @property {Boolean} _withError
	 * @private
	 */
	Future.prototype._withError = false;
	
	/**
	 * Array of registered handlers for *then*, *whenComplete* and *catchError*
	 *
	 * @property {Array} _callbacks
	 * @private
	 */
	Future.prototype._callbacks = null;
	
	/**
	 * Add *onValue* handler to completion of &#x60;Future&#x60;. 
	 * If &#x60;Future&#x60; is already completed, handler is called synchronously, 
	 * otherwise its called just after completion.
	 *
	 * This handler can return new &#x60;data&#x60;, 
	 * &#x60;Future&#x60; which will be chained into process or nothing to keep original value.
	 *
	 * Optionally you can pass onError callback, which is inline version  of *catchError*.
	 *
	 * Any error in *onValue* callback leads to complete result &#x60;Future&#x60; with error.
	 * 
	 * @method then
	 * @param {Function} onValue Function which will be called after completion. It takes one parameter, completion &#x60;data&#x60;.
	 * @param {Object} [options] Map of optional parameters. Currently the only supported is { onError: {Function} }.
	 * @return {Future}
	 */
	Future.prototype.then = function( onValue, options )
	{
		if( !isFunction(onValue) )
		{
			throw new Error(&quot;onValue callback must be a function&quot;);
		}
		
		var onError = options;
		
		if( onError != null &amp;&amp; !isUndefined(onError) &amp;&amp; !isFunction(onError) )
		{
			options = options || {};
			onError = options.onError;
			
			if( !isFunction(onError) )
			{
				throw new Error(&quot;onError callback must be a function&quot;);
			}
		}
		
		var future = new Future();
		
		if ( this._pending )
		{
			this._callbacks.push( { 
				onValue: onValue,
				onError: onError,
				f: future
			} );
		}
		else
		{
			this._innerComplete( { 
				onValue: onValue,
				onError: onError,
				f: future
			}, true);
		}
		
		return future;
	};
	
	/**
	 * Add error handler into &#x60;Future&#x60; completion chain.
	 * 
	 * Result in &#x60;Future&#x60; which completes with &#x60;data&#x60; returned by handler.
	 *
	 * @method catchError
	 * @param {Function} onError Error handler
	 * @param {Function} [test] Callback which should return &#x60;true&#x60; if error is handler and new &#x60;data&#x60; is set for &#x60;Future&#x60;
	 * @return {Future}
	 */
	Future.prototype.catchError = function( onError, test )
	{
		return this.then( function(){}, function( e ){
			if( !test || test( e ) )
			{
				return onError( e );
			}
			
			throw e;
		});
	};
	
	/**
	 * Add callback which is called on success or error.
	 *
	 * Callback can return &#x60;Future&#x60; to chain async task in the process.
	 *
	 * @method whenComplete
	 * @param {Function} action Callback
	 * @return {Future} 
	 */
	Future.prototype.whenComplete = function( action )
	{
		return this.then(
			function( data ){
				var f2 = action();
				if ( f2 instanceof Future ) return f2.then(function(){ return data; });
				return data;
			}, 
			{ onError: function(e){
				var f2 = action();
				if ( f2 instanceof Future ) return f2.then( function(){ throw e; });
				throw e;
			} }
		);
	};
	
	/**
	 * Used by completer to control future.
	 * 
	 * Complete task with data.
	 *
	 * @method _complete
	 * @param {Object} data Value for completion.
	 * @param {Boolean} [sync] Determine if future was completed in sync mode
	 * @private
	 */
	Future.prototype._complete = function( data, sync )
	{
		if( !this._pending )
		{
			throw new Error(&quot;Future already completed&quot;);
		}
		
		this._pending = false;
		this._data = data;
		
		this._dispatchCompletion( sync );
	};
	
	/**
	 * Update object state and trigger completion for registered callbacks.
	 *
	 * @method _innerComplete
	 * @param {Object} data Setting of handler { onValue: fn, onError: fn, f: Future }
	 * @param {Boolean} [sync] Determine if future was completed in sync mode
	 * @private
	 */
	Future.prototype._innerComplete = function( data, sync )
	{
		var result;
		try
		{
			if( this._withError )
			{
				if( !data.onError )
				{
					throw this._error;
				}
				result = data.onError( this._error );
			}
			else
			{
				result = data.onValue( this._data );
			}
		}
		catch( e )
		{
			data.f._completeError( e ,sync );
			return;
		}
		
		if ( isUndefined(result) )
		{
			result = this._data;
		}
		
		if ( result instanceof Future )
		{
			result
				.then(function( v ){
					data.f._complete( v );
				})
				.catchError(function( e ){
					data.f._completeError( e );
				});
		}
		else
		{
			data.f._complete( result, sync );
		}
	};
	
	/**
	 * Used by completer to control future.
	 *
	 * Complete task with error.
	 *
	 * @method _completeError
	 * @param {Object} error Error object.
	 * @param {Boolean} [sync] Determine if future was completed in sync mode
	 * @private
	 */
	Future.prototype._completeError = function( error, sync )
	{
		if( !this._pending )
		{
			throw new Error(&quot;Future already completed&quot;);
		}
		
		this._pending = false;
		this._withError = true;
		this._error = error;
		
		this._dispatchCompletion( sync );
	};
	
	/**
	 * Prepare for propagate completion to registered handlers. Decide which mode it should go:
	 * 
	 * normal, for sync != true
	 * fake-async, for sync == true
	 *
	 * @method _dispatchCompletion
	 * @param {Boolean} [sync] Determine if future was completed in sync mode
	 * @private
	 */
	Future.prototype._dispatchCompletion = function( sync )
	{
		if ( sync )
		{
			var self = this;
			self._pending = true;
			nextTick(function(){
				self._pending = false;
				self._actualDispatchCompletion( );
			});
		}
		else
		{
			this._actualDispatchCompletion();
		}
	};
	
	/**
	 * Propagate completion to registered handlers.
	 *
	 * @method _actualDispatchCompletion
	 * @private
	 */
	Future.prototype._actualDispatchCompletion = function(){
		var len = this._callbacks.length;
		
		if ( this._withError &amp;&amp; len == 0 )
		{
			throw this._error;
		}
			
		for( var i = 0; i &lt; len; i++ )
		{
			this._innerComplete( this._callbacks[i] );
		}
	};
	
	/**
	 * Create &#x60;Future&#x60; when completes when all given &#x60;Future&#x60;s complete.
	 *
	 * When one or more input &#x60;Future&#x60;s completes with error, result &#x60;Future&#x60; result in error as well.
	 * 
	 * @method wait
	 * @param {Array} list List of &#x60;Future&#x60;s to wait for
	 * @return {Future} Gathering object
	 * @static
	 */
	Future.wait = function( list ){
		if( !isArray( list ) )
		{
			throw new Error(&quot;List of futures to wait must be an array, &quot; + list + &quot; given&quot;);
		}
		
		if ( list.length == 0 )
		{
			return new Future.value([]);
		}
		
		var completer = new Completer(),
			pending = list.length,
			data = new Array( pending );
			
			
		function process(index){
			list[index].then(function(d){
				pending--;
				data[index] = d;
				
				if ( pending &lt;= 0 )
				{
					completer.complete( data );
				}
			})
			.catchError(function(e){
				if ( !completer.isCompleted() )
				{
					completer.completeError( e );
				}
			});
		}
		
		for( var i = 0; i &lt; list.length; i++ )
		{
			if ( list[i] instanceof Future )
			{
				process( i );
			}
			else
			{
				throw new Error( list[i] + &quot; is not a Future&quot;);
			}
		}
		
		return completer.future;
	};
	
	/**
	 * Perform asynchronous task on list of elements.
	 *
	 * @method forEach
	 * @param {Array} list Input for iteration
	 * @param {Function} fn Function to call on each element. Should return &#x60;Future&#x60;
	 * @return {Future} &#x60;Future&#x60; which completes when all async task complete.
	 * @static
	 */
	Future.forEach = function( list, fn ){
		var futures = [];
		
		for ( var i = 0; i &lt; list.length; i++ ){
			var future = fn( list[i] );
			if ( !(future instanceof Future) )
			{
				throw new Error(&quot;Returned element &quot; + list[i] + &quot; is not a Future&quot;);
			}
			futures.push( future );
		}
		
		return this.wait(futures);
	};
	
	/**
	 * &#x60;Completer&#x60; represents controller of asynchronous task.
	 * 
	 *	@class Completer
	 *	@constructor
	 */
	var Completer = function()
	{ 
		this.future = new Future();
	};
	
	/**
	 * &#x60;Future&#x60; object assigned to this completer
	 *
	 * @property {Future} future
	 */
	Completer.prototype.future = null;
	
	/**
	 * Complete assigned future with &#x60;data&#x60;.
	 * 
	 * @method complete
	 * @param {Object} data
	 */
	Completer.prototype.complete = function( data )
	{
		this.future._complete( data );
	};
	
	/**
	 * Complete assigned future with error. 
	 *
	 * @method completeError
	 * @param {Object} error
	 */
	Completer.prototype.completeError = function( error )
	{
		this.future._completeError( error );
	};
	
	/**
	 * Return &#x60;true&#x60; if object is completed with data or error, &#x60;false&#x60; otherwise.
	 *
	 * @method isCompleted
	 * @return {Boolean}
	 */
	Completer.prototype.isCompleted = function()
	{
		return !this.future._pending;
	};
	
	if ( typeof exports != &#x27;undefined&#x27; ) 
	{
		module.exports.Future = Future;
		module.exports.Completer = Completer;
	}
	else if ( typeof define != &#x27;undefined&#x27; )
	{
		define({
			Future: Future,
			Completer: Completer
		});
	}
	else 
	{
		root.Future = Future;
		root.Completer = Completer;
	}
	
	function isUndefined(obj)
	{
		return typeof(obj) == &quot;undefined&quot;;
	}
	
	function isFunction(obj) 
	{
		  return Object.prototype.toString.call(obj) == &#x27;[object Function]&#x27;;
	}
	
	function isArray(obj){
		return Object.prototype.toString.call(obj) == &#x27;[object Array]&#x27;;
	}
	
})();
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
